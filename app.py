from flask import Flask, render_template, request, jsonify, send_file
import yt_dlp
import os
import platform
import tempfile
import random
import re
import requests
import time
import json
from datetime import datetime, timedelta
from http.cookiejar import MozillaCookieJar

app = Flask(__name__)

# YouTube consent cookie
YOUTUBE_CONSENT = 'YES+cb.20240318-17-p0.en-GB+FX+{}'.format(random.randint(100, 999))

# reCAPTCHA settings
RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')
RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')
RECAPTCHA_VERIFY_URL = "https://www.google.com/recaptcha/api/siteverify"

if not RECAPTCHA_SITE_KEY or not RECAPTCHA_SECRET_KEY:
    print("Warning: reCAPTCHA keys not set. Please set RECAPTCHA_SITE_KEY and RECAPTCHA_SECRET_KEY environment variables.")
    if os.environ.get('FLASK_ENV') == 'development':
        RECAPTCHA_SITE_KEY = "YOUR_SITE_KEY"
        RECAPTCHA_SECRET_KEY = "YOUR_SECRET_KEY"

# Configure download folder
if os.environ.get('FLASK_ENV') == 'production':
    DOWNLOAD_FOLDER = '/tmp/downloads'
else:
    if platform.system() == 'Windows':
        DOWNLOAD_FOLDER = os.path.join(os.environ.get('USERPROFILE', ''), 'Downloads')
    else:
        DOWNLOAD_FOLDER = os.path.join(os.path.expanduser('~'), 'Downloads')

# Ensure download folder exists
try:
    os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)
except Exception as e:
    print(f"Error creating download folder: {e}")
    DOWNLOAD_FOLDER = tempfile.mkdtemp()
    print(f"Using temporary download folder: {DOWNLOAD_FOLDER}")

# List of free SOCKS5 proxies (update these regularly)
PROXY_LIST = [
    'socks5://51.79.51.246:443',
    'socks5://192.111.137.35:4145',
    'socks5://72.206.181.97:64943',
    'socks5://192.111.139.163:19404',
    'socks5://47.243.95.228:10080'
]

def get_working_proxy():
    """Test and return a working proxy"""
    for proxy in PROXY_LIST:
        try:
            response = requests.get('https://www.youtube.com', 
                                  proxies={'http': proxy, 'https': proxy},
                                  timeout=10)
            if response.status_code == 200:
                return proxy
        except:
            continue
    return None

def get_random_user_agent():
    user_agents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2.1 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Edge/122.0.2365.66',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'
    ]
    return random.choice(user_agents)

def get_browser_like_headers():
    user_agent = get_random_user_agent()
    chrome_version = "122.0.0.0"
    
    return {
        'User-Agent': user_agent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Cache-Control': 'max-age=0',
        'sec-ch-ua': f'"Chromium";v="{chrome_version}", "Google Chrome";v="{chrome_version}", "Not(A:Brand";v="24"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-ch-ua-platform-version': '"15.0.0"',
        'Sec-CH-UA-Arch': '"x86"',
        'Sec-CH-UA-Full-Version': chrome_version,
        'Sec-CH-UA-Full-Version-List': f'"Chromium";v="{chrome_version}", "Google Chrome";v="{chrome_version}", "Not(A:Brand";v="24.0.0.0"',
        'DNT': '1',
        'Pragma': 'no-cache',
        'Priority': 'u=0, i',
        'Origin': 'https://www.youtube.com',
        'Referer': 'https://www.youtube.com/',
        'X-YouTube-Client-Name': '1',
        'X-YouTube-Client-Version': '2.20240321.04.00'
    }

def verify_recaptcha(response):
    try:
        data = {
            'secret': RECAPTCHA_SECRET_KEY,
            'response': response
        }
        r = requests.post(RECAPTCHA_VERIFY_URL, data=data)
        result = r.json()
        return result.get('success', False)
    except Exception as e:
        print(f"reCAPTCHA verification error: {e}")
        return False

def create_cookie_file():
    cookie_file = os.path.join(tempfile.gettempdir(), 'youtube_cookies.txt')
    
    # Create cookie file in Netscape format
    with open(cookie_file, 'w', encoding='utf-8') as f:
        f.write('# Netscape HTTP Cookie File\n')
        f.write('# https://curl.haxx.se/rfc/cookie_spec.html\n')
        f.write('# This file was generated by yt-dlp.  Do not edit.\n\n')
        
        # Current timestamp and one year from now
        current_time = int(datetime.now().timestamp())
        expiry = current_time + 31536000  # 1 year from now
        
        # Add required YouTube cookies
        cookies = [
            # CONSENT cookie
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tCONSENT\t{YOUTUBE_CONSENT}',
            # VISITOR_INFO1_LIVE cookie
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tVISITOR_INFO1_LIVE\t{random.randint(10**10, (10**11)-1)}',
            # GPS cookie
            f'.youtube.com\tTRUE\t/\tFALSE\t{current_time + 3600}\tGPS\t1',
            # PREF cookie
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tPREF\tf6=8&hl=en&f5=30000',
            # YSC cookie
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tYSC\t{random.randint(10**10, (10**11)-1)}',
            # Additional cookies
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tLOGIN_INFO\tdummy_token',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tSAPISID\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tSID\tdummy_sid',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tSSID\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tHSID\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tAEC\t{random.randint(10**10, (10**11)-1)}'
        ]
        
        # Write each cookie on a new line
        for cookie in cookies:
            f.write(cookie + '\n')
    
    # Verify the cookie file
    if not os.path.exists(cookie_file):
        raise Exception("Failed to create cookie file")
        
    return cookie_file

@app.route("/", methods=["GET"])
def index():
    return render_template("index.html", recaptcha_site_key=RECAPTCHA_SITE_KEY)

@app.route("/download", methods=["POST"])
def download():
    # Verify reCAPTCHA first
    recaptcha_response = request.form.get('g-recaptcha-response')
    if not recaptcha_response:
        return jsonify({
            "error": "Please complete the reCAPTCHA verification.",
            "details": "reCAPTCHA verification is required"
        })

    if not verify_recaptcha(recaptcha_response):
        return jsonify({
            "error": "reCAPTCHA verification failed. Please try again.",
            "details": "Invalid reCAPTCHA response"
        })

    url = request.form["url"]
    quality = request.form["quality"]

    try:
        # Create a unique download directory
        download_dir = tempfile.mkdtemp(dir=DOWNLOAD_FOLDER)
        print(f"Download directory: {download_dir}")

        # Get a working proxy
        proxy = get_working_proxy()
        if proxy:
            print(f"Using proxy: {proxy}")

        # Create cookie file
        try:
            cookie_file = create_cookie_file()
            print(f"Cookie file created at: {cookie_file}")
        except Exception as e:
            print(f"Error creating cookie file: {e}")
            cookie_file = None

        # Basic options with enhanced browser-like settings
        options = {
            "quiet": True,
            "no_warnings": True,
            "http_headers": get_browser_like_headers(),
            "nocheckcertificate": True,
            "prefer_insecure": True,
            "sleep_interval": 3,
            "max_sleep_interval": 7,
            "sleep_interval_requests": 3,
            "ignoreerrors": False,
            "no_color": True,
            "geo_bypass": True,
            "geo_bypass_country": "US",
            "socket_timeout": 30,
            "retries": 5,
            "fragment_retries": 10,
            "force_generic_extractor": False,
            "concurrent_fragment_downloads": 1,
            "noplaylist": True,
            "extract_flat": False,
            "extractor_retries": 3,
            "file_access_retries": 3,
            "hls_prefer_native": True,
            "external_downloader": None,
            "format_sort": ["res", "ext:mp4:m4a", "codec:h264:aac", "size", "br", "asr"],
            "allow_unplayable_formats": True,
            "check_formats": False,
            "youtube_include_dash_manifest": True,
            "youtube_include_hls_manifest": True,
            "prefer_native_hls": True,
            "writethumbnail": False,
            "writesubtitles": False,
            "writeautomaticsub": False,
            "allsubtitles": False,
            "subtitlesformat": "srt",
            "merge_output_format": "mp4",
            "final_ext": "mp4",
            "postprocessor_args": {
                "ffmpeg": ["-c", "copy"]
            }
        }

        if proxy:
            options["proxy"] = proxy

        if cookie_file:
            options["cookiefile"] = cookie_file

        # First extract video info to get the title
        with yt_dlp.YoutubeDL(options) as ydl:
            try:
                print(f"Extracting info for URL: {url}")
                meta = None
                last_error = None
                
                for attempt in range(3):
                    try:
                        meta = ydl.extract_info(url, download=False)
                        if meta:
                            break
                    except Exception as e:
                        last_error = e
                        print(f"Info extraction attempt {attempt + 1} failed: {str(e)}")
                        time.sleep(5 * (attempt + 1))
                        # Try a different proxy on retry
                        proxy = get_working_proxy()
                        if proxy:
                            options["proxy"] = proxy
                            ydl = yt_dlp.YoutubeDL(options)
                
                if not meta:
                    raise last_error or Exception("Could not extract video metadata")

                # Clean and prepare the filename
                video_title = meta.get('title', '')
                if not video_title:
                    video_title = f"youtube_video_{int(time.time())}"
                
                # Clean the title to make it filesystem safe
                video_title = re.sub(r'[<>:"/\\|?*]', '', video_title)
                video_title = video_title.strip()[:200]

                # Set up download options with proper filename
                if quality == "audio":
                    final_filename = f"{video_title}.mp3"
                    output_template = os.path.join(download_dir, "%(title)s.%(ext)s")
                    options.update({
                        "outtmpl": output_template,
                        "format": "bestaudio[ext=m4a]/bestaudio/best",
                        "postprocessors": [{
                            "key": "FFmpegExtractAudio",
                            "preferredcodec": "mp3",
                            "preferredquality": "192"
                        }]
                    })
                else:
                    final_filename = f"{video_title}.mp4"
                    output_template = os.path.join(download_dir, "%(title)s.%(ext)s")
                    format_map = {
                        "best": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
                        "high": "(bestvideo[height<=720][ext=mp4]//bestvideo[height<=720])+(bestaudio[ext=m4a]/bestaudio)/best[height<=720]",
                        "medium": "(bestvideo[height<=480][ext=mp4]//bestvideo[height<=480])+(bestaudio[ext=m4a]/bestaudio)/best[height<=480]",
                        "low": "(bestvideo[height<=360][ext=mp4]//bestvideo[height<=360])+(bestaudio[ext=m4a]/bestaudio)/best[height<=360]"
                    }
                    options.update({
                        "outtmpl": output_template,
                        "format": format_map.get(quality, format_map["best"])
                    })

                print("Starting download with options:", json.dumps(options, indent=2))

                # Download with retry logic
                max_retries = 3
                for attempt in range(max_retries):
                    try:
                        print(f"Download attempt {attempt + 1}/{max_retries}")
                        ydl.download([url])
                        break
                    except Exception as e:
                        if attempt == max_retries - 1:
                            raise
                        print(f"Attempt {attempt + 1} failed: {str(e)}")
                        time.sleep(5 * (attempt + 1))
                        # Try a different proxy on retry
                        proxy = get_working_proxy()
                        if proxy:
                            options["proxy"] = proxy
                            ydl = yt_dlp.YoutubeDL(options)

                # Look for the downloaded file
                downloaded_files = os.listdir(download_dir)
                if not downloaded_files:
                    raise Exception("No files were downloaded")

                # Get the actual downloaded file
                actual_file = downloaded_files[0]
                actual_filepath = os.path.join(download_dir, actual_file)

                if not os.path.exists(actual_filepath):
                    raise Exception("Downloaded file not found")

                print(f"File downloaded successfully: {actual_filepath}")
                
                # Send the file with proper filename and mime type
                mimetype = 'audio/mpeg' if quality == "audio" else 'video/mp4'
                response = send_file(
                    actual_filepath,
                    as_attachment=True,
                    download_name=final_filename,
                    mimetype=mimetype
                )
                
                # Clean up files after sending
                @response.call_on_close
                def cleanup():
                    try:
                        if os.path.exists(actual_filepath):
                            os.remove(actual_filepath)
                        if os.path.exists(download_dir):
                            os.rmdir(download_dir)
                        if cookie_file and os.path.exists(cookie_file):
                            os.remove(cookie_file)
                    except Exception as e:
                        print(f"Cleanup error: {e}")
                
                return response

            except Exception as e:
                # Clean up on error
                try:
                    if cookie_file and os.path.exists(cookie_file):
                        os.remove(cookie_file)
                    if os.path.exists(download_dir):
                        import shutil
                        shutil.rmtree(download_dir)
                except:
                    pass
                    
                error_msg = str(e)
                if "Sign in to confirm you're not a bot" in error_msg:
                    error_msg = "YouTube is detecting automated access. Please try again in a few minutes or try a different video."
                print(f"Download error: {error_msg}")
                return jsonify({
                    "error": error_msg,
                    "details": "Try a different video or quality setting"
                })

    except Exception as e:
        print(f"General error: {str(e)}")
        return jsonify({
            "error": str(e),
            "details": "An unexpected error occurred"
        })

@app.route("/get_file/<filename>")
def get_file(filename):
    return "File download method changed", 410

if __name__ == "__main__":
    app.run(debug=True)         