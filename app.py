from flask import Flask, render_template, request, jsonify, send_file
import yt_dlp
import os
import platform
import tempfile
import random
import re
import requests
import time
import json
from datetime import datetime, timedelta
from http.cookiejar import MozillaCookieJar
from urllib.parse import parse_qs, urlparse
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
import shutil
from fake_useragent import UserAgent
import string

app = Flask(__name__)

# YouTube consent cookie
YOUTUBE_CONSENT = 'YES+cb.20240318-17-p0.en-GB+FX+{}'.format(random.randint(100, 999))

# reCAPTCHA settings
RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')
RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')
RECAPTCHA_VERIFY_URL = "https://www.google.com/recaptcha/api/siteverify"

if not RECAPTCHA_SITE_KEY or not RECAPTCHA_SECRET_KEY:
    print("Warning: reCAPTCHA keys not set. Please set RECAPTCHA_SITE_KEY and RECAPTCHA_SECRET_KEY environment variables.")
    if os.environ.get('FLASK_ENV') == 'development':
        RECAPTCHA_SITE_KEY = "YOUR_SITE_KEY"
        RECAPTCHA_SECRET_KEY = "YOUR_SECRET_KEY"

# Configure download folder
if os.environ.get('FLASK_ENV') == 'production':
    DOWNLOAD_FOLDER = '/tmp/downloads'
else:
    if platform.system() == 'Windows':
        DOWNLOAD_FOLDER = os.path.join(os.environ.get('USERPROFILE', ''), 'Downloads')
    else:
        DOWNLOAD_FOLDER = os.path.join(os.path.expanduser('~'), 'Downloads')

# Ensure download folder exists
try:
    os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)
except Exception as e:
    print(f"Error creating download folder: {e}")
    DOWNLOAD_FOLDER = tempfile.mkdtemp()
    print(f"Using temporary download folder: {DOWNLOAD_FOLDER}")

# List of free SOCKS5 proxies (update these regularly)
PROXY_LIST = [
    'socks5://192.111.137.34:18765',
    'socks5://192.111.129.145:16894',
    'socks5://98.162.25.16:4145',
    'socks5://72.210.221.197:4145',
    'socks5://192.111.135.17:18302',
    'socks5://192.111.137.37:18762',
    'socks5://192.111.139.165:4145',
    'socks5://192.111.130.2:4145'
]

# YouTube API constants
YOUTUBE_API_KEY = os.environ.get('YOUTUBE_API_KEY', '')
INNERTUBE_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'
INNERTUBE_CLIENT_VERSION = '2.20240321.04.00'
INNERTUBE_CONTEXT = {
    'client': {
        'clientName': 'ANDROID',
        'clientVersion': '18.11.36',
        'androidSdkVersion': 33,
        'osName': 'Android',
        'osVersion': '13',
        'platform': 'MOBILE'
    }
}

# Add these constants at the top after imports
ANDROID_HEADERS = {
    'User-Agent': 'com.google.android.youtube/17.31.35 (Linux; U; Android 11)',
    'Accept': '*/*',
    'Accept-Language': 'en-US,en',
    'Accept-Encoding': 'gzip',
    'x-goog-api-format-version': '2',
    'x-goog-api-key': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8',
    'x-youtube-client-name': '3',
    'x-youtube-client-version': '17.31.35',
    'content-type': 'application/json'
}

def get_working_proxy():
    """Test and return a working proxy"""
    random.shuffle(PROXY_LIST)
    for proxy in PROXY_LIST:
        try:
            proxies = {
                'http': proxy,
                'https': proxy
            }
            response = requests.get('https://www.youtube.com', 
                                 proxies=proxies,
                                 timeout=10)
            if response.status_code == 200:
                print(f"Found working proxy: {proxy}")
                return proxies
        except:
            continue
    return None

def get_random_user_agent():
    user_agents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2.1 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Edge/122.0.2365.66',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'
    ]
    return random.choice(user_agents)

def create_session():
    session = requests.Session()
    retry = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session

def create_cookie_file():
    cookie_file = os.path.join(tempfile.gettempdir(), 'youtube_cookies.txt')
    
    # Create cookie file in Netscape format
    with open(cookie_file, 'w', encoding='utf-8') as f:
        f.write('# Netscape HTTP Cookie File\n')
        f.write('# https://curl.haxx.se/rfc/cookie_spec.html\n')
        f.write('# This file was generated by yt-dlp.  Do not edit.\n\n')
        
        # Current timestamp and one year from now
        current_time = int(datetime.now().timestamp())
        expiry = current_time + 31536000  # 1 year from now
        
        # Add required YouTube cookies with proper domain format
        cookies = [
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tCONSENT\t{YOUTUBE_CONSENT}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tVISITOR_INFO1_LIVE\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{current_time + 3600}\tGPS\t1',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tPREF\tf6=8&hl=en&f5=30000',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tYSC\t{random.randint(10**10, (10**11)-1)}',
            # Add SAPISID cookie for authentication
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tSAPISID\t{random.randint(10**10, (10**11)-1)}',
            # Add additional session cookies
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\t__Secure-1PSID\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\t__Secure-3PSID\t{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tLOGIN_INFO\tAFmmF2swRQIgC{random.randint(10**10, (10**11)-1)}',
            f'.youtube.com\tTRUE\t/\tFALSE\t{expiry}\tSID\tv{random.randint(10**10, (10**11)-1)}'
        ]
        
        # Write each cookie on a new line
        for cookie in cookies:
            f.write(cookie + '\n')
    
    return cookie_file

def get_video_info_with_proxy(url, proxy=None):
    """Get video info using proxy"""
    try:
        ua = UserAgent()
        headers = {
            'User-Agent': ua.random,
            'Accept': 'text/html,application/json',
            'Accept-Language': 'en-US,en;q=0.9',
            'Origin': 'https://www.youtube.com',
            'Referer': 'https://www.youtube.com/'
        }

        # Try with proxy first
        if proxy:
            try:
                response = requests.get(url, headers=headers, proxies=proxy, timeout=15)
                if response.status_code == 200:
                    return response
            except:
                pass

        # Try without proxy as fallback
        return requests.get(url, headers=headers, timeout=15)
    except Exception as e:
        print(f"Error getting video info: {str(e)}")
        raise

def get_browser_like_headers():
    return {
        'User-Agent': 'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.57 Mobile Safari/537.36',
        'Accept': '*/*',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate',
        'Origin': 'https://m.youtube.com',
        'Referer': 'https://m.youtube.com/',
        'X-YouTube-Client-Name': '2',
        'X-YouTube-Client-Version': INNERTUBE_CLIENT_VERSION,
        'X-Goog-Api-Format-Version': '2',
        'sec-ch-ua': '"Not.A/Brand";v="8", "Chromium";v="114"',
        'sec-ch-ua-mobile': '?1',
        'sec-ch-ua-platform': '"Android"',
        'Range': 'bytes=0-',  # Add range header for resumable downloads
        'Cookie': f'CONSENT={YOUTUBE_CONSENT}; VISITOR_INFO1_LIVE={random.randint(10**10, (10**11)-1)}; YSC={random.randint(10**10, (10**11)-1)}'
    }

def verify_recaptcha(response):
    try:
        data = {
            'secret': RECAPTCHA_SECRET_KEY,
            'response': response
        }
        r = requests.post(RECAPTCHA_VERIFY_URL, data=data)
        result = r.json()
        return result.get('success', False)
    except Exception as e:
        print(f"reCAPTCHA verification error: {e}")
        return False

def download_with_progress(url, ydl_opts, max_segments=10):
    """Download video in segments with progress tracking"""
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # First get video info without downloading
            info = ydl.extract_info(url, download=False)
            if not info:
                raise Exception("Could not get video information")

            # Get video format
            formats = info.get('formats', [])
            if not formats:
                raise Exception("No formats available")

            # Select format based on quality settings
            selected_format = None
            for f in formats:
                if f.get('format_id') == ydl_opts.get('format', ''):
                    selected_format = f
                    break
            
            if not selected_format:
                # Use best available format
                selected_format = formats[-1]

            # Get file size
            filesize = selected_format.get('filesize', 0)
            if filesize == 0:
                filesize = selected_format.get('filesize_approx', 0)

            if filesize == 0:
                print("Warning: Could not determine file size, proceeding anyway")
                # Try direct download
                return ydl.extract_info(url, download=True)

            # Calculate segment size
            segment_size = max(filesize // max_segments, 1024 * 1024)  # Minimum 1MB segments
            
            # Create temporary directory for segments
            temp_dir = tempfile.mkdtemp()
            segment_files = []

            try:
                # Download in segments
                for i in range(0, filesize, segment_size):
                    end_byte = min(i + segment_size - 1, filesize - 1)
                    
                    # Update headers for this segment
                    ydl_opts['http_headers']['Range'] = f'bytes={i}-{end_byte}'
                    
                    # Unique name for this segment
                    segment_file = os.path.join(temp_dir, f'segment_{i}_{end_byte}.part')
                    
                    # Try to download this segment with retries
                    max_retries = 5
                    for retry in range(max_retries):
                        try:
                            with yt_dlp.YoutubeDL(ydl_opts) as segment_ydl:
                                segment_info = segment_ydl.extract_info(url, download=True)
                                if os.path.exists(segment_file) and os.path.getsize(segment_file) > 0:
                                    segment_files.append(segment_file)
                                    print(f"Successfully downloaded segment {len(segment_files)}/{max_segments}")
                                    break
                        except Exception as e:
                            print(f"Error downloading segment {i}: {str(e)}")
                            if retry < max_retries - 1:
                                sleep_time = min(30, 5 * (retry + 1))
                                print(f"Retrying in {sleep_time} seconds...")
                                time.sleep(sleep_time)
                            else:
                                raise Exception(f"Failed to download segment after {max_retries} attempts")

                # Verify all segments were downloaded
                if len(segment_files) != max_segments:
                    raise Exception(f"Only downloaded {len(segment_files)}/{max_segments} segments")

                # Combine segments
                output_file = os.path.join(temp_dir, 'combined_file')
                with open(output_file, 'wb') as outfile:
                    for segment in sorted(segment_files):
                        with open(segment, 'rb') as infile:
                            outfile.write(infile.read())

                # Clean up segments
                for segment in segment_files:
                    try:
                        os.remove(segment)
                    except:
                        pass

                return info

            finally:
                # Clean up temp directory
                try:
                    shutil.rmtree(temp_dir)
                except:
                    pass

    except Exception as e:
        print(f"Download error: {str(e)}")
        raise

def generate_session_token():
    """Generate a random session token"""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=32))

def get_video_info(url):
    try:
        # Extract video ID
        video_id = None
        if 'youtu.be' in url:
            video_id = url.split('/')[-1].split('?')[0]
        else:
            parsed_url = urlparse(url)
            video_id = parse_qs(parsed_url.query).get('v', [None])[0]
            if not video_id:
                video_id = parsed_url.path.split('/')[-1].split('?')[0]

        if not video_id:
            print(f"Could not extract video ID from URL: {url}")
            raise Exception("Could not extract video ID")

        print(f"Extracted video ID: {video_id}")

        # Generate session data
        session_token = generate_session_token()
        timestamp = int(time.time())
        
        # Create Android client context
        client_context = {
            'context': {
                'client': {
                    'clientName': 'ANDROID',
                    'clientVersion': '17.31.35',
                    'androidSdkVersion': 30,
                    'osName': 'Android',
                    'osVersion': '11',
                    'platform': 'MOBILE',
                    'clientFormFactor': 'SMALL_FORM_FACTOR',
                    'timeZone': 'UTC',
                    'browserName': 'Chrome Mobile',
                    'browserVersion': '117.0.0.0',
                    'userAgent': ANDROID_HEADERS['User-Agent'],
                    'acceptHeader': ANDROID_HEADERS['Accept'],
                    'deviceMake': 'Google',
                    'deviceModel': 'Pixel 6',
                },
                'user': {
                    'lockedSafetyMode': False
                },
                'request': {
                    'useSsl': True,
                    'internalExperimentFlags': [],
                    'consistencyTokenJars': []
                }
            }
        }

        # First request - Get player
        player_url = f'https://youtubei.googleapis.com/youtubei/v1/player?key={ANDROID_HEADERS["x-goog-api-key"]}'
        player_data = {
            **client_context,
            'videoId': video_id,
            'playbackContext': {
                'contentPlaybackContext': {
                    'html5Preference': 'HTML5_PREF_WANTS',
                    'lactMilliseconds': str(timestamp),
                    'referer': f'https://m.youtube.com/watch?v={video_id}',
                    'signatureTimestamp': '19369',
                    'autonavState': 'STATE_ON',
                    'autoCaptionsDefaultOn': False,
                }
            },
            'racyCheckOk': True,
            'contentCheckOk': True
        }

        # Make player request
        print("Requesting video player data...")
        response = requests.post(
            player_url,
            headers=ANDROID_HEADERS,
            json=player_data,
            timeout=15
        )
        
        if response.status_code != 200:
            print(f"Player request failed with status {response.status_code}")
            raise Exception("Failed to get video player data")

        player_response = response.json()
        
        # Check for errors in player response
        if 'playabilityStatus' in player_response:
            status = player_response['playabilityStatus']
            if status.get('status') != 'OK':
                error = status.get('reason', 'Unknown error')
                print(f"Video not playable: {error}")
                raise Exception(f"Video not available: {error}")

        # Extract necessary info
        meta = {
            'id': video_id,
            'title': player_response.get('videoDetails', {}).get('title', ''),
            'duration': int(player_response.get('videoDetails', {}).get('lengthSeconds', 0)),
            'formats': []
        }

        # Extract formats
        if 'streamingData' in player_response:
            formats = []
            if 'formats' in player_response['streamingData']:
                formats.extend(player_response['streamingData']['formats'])
            if 'adaptiveFormats' in player_response['streamingData']:
                formats.extend(player_response['streamingData']['adaptiveFormats'])
            
            meta['formats'] = formats

        return meta

    except Exception as e:
        print(f"Error in get_video_info: {str(e)}")
        raise

@app.route("/", methods=["GET"])
def index():
    return render_template("index.html", recaptcha_site_key=RECAPTCHA_SITE_KEY)

@app.route("/download", methods=["POST"])
def download():
    # Verify reCAPTCHA first
    recaptcha_response = request.form.get('g-recaptcha-response')
    if not recaptcha_response:
        return jsonify({
            "error": "Please complete the reCAPTCHA verification.",
            "details": "reCAPTCHA verification is required"
        })

    if not verify_recaptcha(recaptcha_response):
        return jsonify({
            "error": "reCAPTCHA verification failed. Please try again.",
            "details": "Invalid reCAPTCHA response"
        })

    url = request.form["url"]
    quality = request.form["quality"]

    try:
        # Create a unique download directory
        download_dir = tempfile.mkdtemp(dir=DOWNLOAD_FOLDER)
        print(f"Download directory: {download_dir}")

        # Configure yt-dlp options
        ydl_opts = {
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' if quality != "audio" else 'bestaudio[ext=m4a]/best',
            'outtmpl': os.path.join(download_dir, '%(title)s.%(ext)s'),
            'quiet': False,
            'verbose': True,
            'no_warnings': False,
            'nocheckcertificate': True,
            'socket_timeout': 30,
            'retries': 10,
            'file_access_retries': 10,
            'fragment_retries': 10,
            'retry_sleep': lambda n: 5 * (n + 1),
            'max_sleep_interval': 30,
            'skip_download': False,
            'overwrites': True,
            'ignoreerrors': False,
            'logtostderr': True,
            'prefer_insecure': True,
            'cachedir': False,
            'no_color': True,
            'progress_hooks': [lambda d: print(f"Download progress: {d.get('downloaded_bytes', 0)}/{d.get('total_bytes', 0)} bytes")],
            'http_headers': ANDROID_HEADERS
        }

        if quality == "audio":
            ydl_opts.update({
                'format': 'bestaudio/best',
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
            })
        else:
            quality_formats = {
                'best': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                'high': 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720]',
                'medium': 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/best[height<=480]',
                'low': 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/best[height<=360]'
            }
            ydl_opts.update({
                'format': quality_formats.get(quality, 'best'),
                'merge_output_format': 'mp4'
            })

        # Try to get video info first
        max_retries = 3
        video_info = None
        last_error = None

        for attempt in range(max_retries):
            try:
                print(f"Attempt {attempt + 1} to get video info...")
                video_info = get_video_info(url)
                if video_info:
                    print("Successfully got video info")
                    break
            except Exception as e:
                last_error = str(e)
                print(f"Attempt {attempt + 1} failed: {last_error}")
                if attempt < max_retries - 1:
                    time.sleep(5 * (attempt + 1))

        if not video_info:
            raise Exception(f"Failed to get video information after {max_retries} attempts. Last error: {last_error}")

        # Try download with retries
        for attempt in range(max_retries):
            try:
                print(f"Download attempt {attempt + 1}/{max_retries}")
                
                if attempt > 0:
                    sleep_time = min(30, 5 * (attempt + 1))
                    print(f"Waiting {sleep_time} seconds before retry...")
                    time.sleep(sleep_time)

                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(url, download=True)
                    if info:
                        print("Download completed successfully")
                        break

            except Exception as e:
                print(f"Download attempt {attempt + 1} failed: {str(e)}")
                if attempt < max_retries - 1:
                    continue
                else:
                    raise Exception(f"Download failed after {max_retries} attempts")

        if not info:
            raise Exception("Download failed - no video information available")

        # Get the output file path
        video_title = info.get('title', f'video_{int(time.time())}')
        video_title = re.sub(r'[<>:"/\\|?*]', '', video_title).strip()[:200]
        ext = 'mp3' if quality == "audio" else 'mp4'
        output_file = os.path.join(download_dir, f"{video_title}.{ext}")

        # Verify the file exists and has content
        if not os.path.exists(output_file):
            # Try to find any file in the directory
            files = os.listdir(download_dir)
            if files:
                output_file = os.path.join(download_dir, files[0])
            else:
                raise Exception("Download failed - file not found")

        if os.path.getsize(output_file) == 0:
            raise Exception("Download failed - empty file")

        print(f"File downloaded successfully: {output_file}")

        # Send the file
        try:
            response = send_file(
                output_file,
                as_attachment=True,
                download_name=os.path.basename(output_file),
                mimetype='audio/mpeg' if quality == "audio" else 'video/mp4'
            )

            # Clean up after sending
            @response.call_on_close
            def cleanup():
                try:
                    if os.path.exists(output_file):
                        os.remove(output_file)
                    if os.path.exists(download_dir):
                        os.rmdir(download_dir)
                except Exception as e:
                    print(f"Cleanup error: {e}")

            return response

        except Exception as e:
            print(f"Error sending file: {e}")
            raise

    except Exception as e:
        error_msg = str(e)
        if "Sign in to confirm you're not a bot" in error_msg:
            error_msg = "YouTube is detecting automated access. Please try again with a different video or quality setting."
        print(f"Download error: {error_msg}")
        
        # Clean up on error
        try:
            if os.path.exists(download_dir):
                shutil.rmtree(download_dir)
        except:
            pass
        
        return jsonify({
            "error": error_msg,
            "details": "Try a different video or quality setting"
        })

@app.route("/get_file/<filename>")
def get_file(filename):
    return "File download method changed", 410

if __name__ == "__main__":
    app.run(debug=True)         